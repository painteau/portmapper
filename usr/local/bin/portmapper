#!/bin/bash

# Configuration file
CONFIG_FILE="/etc/portmapper.conf"

# Default variables
DB_FILE="/var/lib/portmapper.db"
START_PORT=3000
END_PORT=65535
LOG_FILE="/var/log/portmapper.log"
BACKUP_DIR="/var/lib/portmapper_backups"
HISTORY_FILE="/var/log/portmapper_history.log"
VERSION="1.1.6"

# Lock file for concurrent access protection
LOCK_FILE="/var/run/portmapper.lock"
LOCK_FD=200

# Function to acquire lock
function acquire_lock {
    eval "exec $LOCK_FD>$LOCK_FILE"
    flock -n $LOCK_FD || error "Another instance of portmapper is running. Please wait."
}

# Function to release lock
function release_lock {
    flock -u $LOCK_FD 2>/dev/null || true
}

# Function to create the default configuration file
function create_default_config {
    local config_file="$1"
    if [ ! -f "$config_file" ]; then
        echo "# Portmapper configuration file" > "$config_file"
        echo "DB_FILE=\"/var/lib/portmapper.db\"" >> "$config_file"
        echo "START_PORT=3000" >> "$config_file"
        echo "END_PORT=65535" >> "$config_file"
        echo "LOG_FILE=\"/var/log/portmapper.log\"" >> "$config_file"
        echo "BACKUP_DIR=\"/var/lib/portmapper_backups\"" >> "$config_file"
        echo "HISTORY_FILE=\"/var/log/portmapper_history.log\"" >> "$config_file"
        log_action "INFO" "Created default configuration file at $config_file" 2>/dev/null || true
    fi
}

# Function to safely load configuration (prevents code injection)
function load_config {
    local config_file="$1"
    create_default_config "$config_file"

    if [ -f "$config_file" ]; then
        # Safely parse configuration file (prevent code injection)
        while IFS='=' read -r key value; do
            # Skip comments and empty lines
            [[ "$key" =~ ^#.*$ ]] && continue
            [[ -z "$key" ]] && continue

            # Remove quotes from value
            value=$(echo "$value" | sed -e 's/^"//' -e 's/"$//' -e "s/^'//" -e "s/'$//")

            # Only allow specific variables
            case "$key" in
                DB_FILE)
                    DB_FILE="$value"
                    ;;
                START_PORT)
                    START_PORT="$value"
                    ;;
                END_PORT)
                    END_PORT="$value"
                    ;;
                LOG_FILE)
                    LOG_FILE="$value"
                    ;;
                BACKUP_DIR)
                    BACKUP_DIR="$value"
                    ;;
                HISTORY_FILE)
                    HISTORY_FILE="$value"
                    ;;
            esac
        done < "$config_file"
    else
        echo "Warning: Config file $config_file does not exist. Using defaults." >&2
    fi
}

# Load the configuration
load_config "$CONFIG_FILE"

# Function to check dependencies
function check_dependencies {
    local deps=("$@")
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            error "$dep is not installed. Please install it to use this feature."
        fi
    done
}

# Function to ensure paths exist
function ensure_path_exists {
    local path="$1"
    local type="$2" # 'file' or 'directory'

    if [ "$type" == "file" ]; then
        local dir
        dir=$(dirname "$path")
        if [ ! -d "$dir" ]; then
            mkdir -p "$dir" || error "Cannot create directory $dir"
        fi
        if [ ! -f "$path" ]; then
            touch "$path" || error "Cannot create file $path"
        fi
    elif [ "$type" == "directory" ]; then
        if [ ! -d "$path" ]; then
            mkdir -p "$path" || error "Cannot create directory $path"
        fi
    fi
}

# Function to check file permissions
function check_file_permissions {
    local file="$1"
    if [ ! -w "$file" ]; then
        error "No write permissions for $file."
    fi
}

# Function to log actions
function log_action {
    local level="$1"
    local message="$2"
    ensure_path_exists "$LOG_FILE" file 2>/dev/null || true
    echo "$(date +'%Y-%m-%d %H:%M:%S') - [$level] - $message" >> "$LOG_FILE" 2>/dev/null || true
}

# Function to log history
function log_history {
    local action="$1"
    local details="$2"
    ensure_path_exists "$HISTORY_FILE" file 2>/dev/null || true
    echo "$(date +'%Y-%m-%d %H:%M:%S') - $action - $details" >> "$HISTORY_FILE" 2>/dev/null || true
}

# Function to display errors and exit
function error {
    echo "Error: $1" >&2
    log_action "ERROR" "$1"
    release_lock
    exit 1
}

# Function to highlight a message
function highlight {
    echo -e "\033[1;32m$1\033[0m"
}

# Function to validate port number
function validate_port {
    local port="$1"

    # Check if port is a number
    if ! [[ "$port" =~ ^[0-9]+$ ]]; then
        error "Invalid port number: $port. Port must be a number."
    fi

    # Check if port is in valid range (1-65535)
    if [ "$port" -lt 1 ] || [ "$port" -gt 65535 ]; then
        error "Invalid port number: $port. Port must be between 1 and 65535."
    fi

    # Check if port is in configured range
    if [ "$port" -lt "$START_PORT" ] || [ "$port" -gt "$END_PORT" ]; then
        error "Port $port is outside the configured range $START_PORT-$END_PORT."
    fi
}

# Function to escape JSON strings
function escape_json {
    local string="$1"
    # Escape backslashes, quotes, and control characters for JSON
    echo "$string" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed 's/\t/\\t/g' | sed 's/\r/\\r/g' | sed 's/\n/\\n/g'
}

# Function to list ports
function list_ports {
    ensure_path_exists "$DB_FILE" file

    if [ ! -s "$DB_FILE" ]; then
        echo "No ports registered in the database."
        exit 0
    fi

    echo -e "+---------+------------+-------------------+-----------------------+---------------------+"
    echo -e "|  Port   |  Protocol  |       Name        |      Description      |     Date Added      |"
    echo -e "+---------+------------+-------------------+-----------------------+---------------------+"

    while IFS=, read -r port protocol name description date_added; do
        description=$(echo "$description" | sed 's/^"\(.*\)"$/\1/')
        wrapped_description=$(echo "$description" | fold -s -w 22)
        first_line=true

        while IFS= read -r desc_line; do
            if [ -z "$desc_line" ]; then
                desc_line=" "
            fi

            if [ "$first_line" = true ]; then
                printf "| %-7s | %-10s | %-17s | %-21s | %-19s |\n" "$port" "$protocol" "$name" "$desc_line" "$date_added"
                first_line=false
            else
                printf "| %-7s | %-10s | %-17s | %-21s | %-19s |\n" " " " " " " "$desc_line" " "
            fi
        done <<< "$wrapped_description"
    done < "$DB_FILE"

    echo -e "+---------+------------+-------------------+-----------------------+---------------------+"
}

# Function to find the next available port
function find_next_free_port {
    ensure_path_exists "$DB_FILE" file

    for port in $(seq "$START_PORT" "$END_PORT"); do
        if ! grep -q "^${port}," "$DB_FILE" 2>/dev/null; then
            echo "$port"
            return
        fi
    done
    error "No available ports in the range $START_PORT-$END_PORT."
}

# Function to check if a port is used by the system (improved)
function is_port_used {
    local port="$1"
    local protocol="$2"  # "tcp" or "udp"

    # Normalize protocol to lowercase for ss command
    protocol=$(echo "$protocol" | tr '[:upper:]' '[:lower:]')

    # Check if the port is used with ss (improved regex to avoid false positives)
    if ss -${protocol}ln | grep -qE "[:.]${port}[[:space:]]"; then
        return 0  # Port is used
    else
        return 1  # Port is free
    fi
}

# Function to add a port
function add_port {
    local port="$1"
    local protocol="$2"  # "TCP" or "UDP"
    local name="$3"
    local description="${4:-}"
    local date_added
    date_added=$(date +'%Y-%m-%d %H:%M:%S')

    # Validate port number
    validate_port "$port"

    # Normalize protocol to uppercase
    protocol=$(echo "$protocol" | tr '[:lower:]' '[:upper:]')

    # Validate protocol
    if [[ "$protocol" != "TCP" && "$protocol" != "UDP" ]]; then
        error "Invalid protocol. Use 'TCP' or 'UDP'."
    fi

    # Check if the port is already used by the system
    if is_port_used "$port" "$protocol"; then
        error "Port $port is already in use by the system."
    fi

    ensure_path_exists "$DB_FILE" file

    # Check if the port already exists in the database
    if grep -q "^${port}," "$DB_FILE" 2>/dev/null; then
        error "Port $port already exists in the database."
    fi

    # Add the port to the database
    echo "$port,$protocol,$name,\"$description\",$date_added" >> "$DB_FILE"
    log_action "INFO" "Added port $port with protocol '$protocol', name '$name', description '$description', and date '$date_added'"
    log_history "ADD" "Port $port added with protocol '$protocol', name '$name', description '$description'"
    highlight "Port $port has been successfully added."

    backup_db
}

# Function to modify a port
function modify_port {
    local port="$1"
    local protocol="$2"  # "TCP" or "UDP"
    local name="$3"
    local description="${4:-}"

    # Validate port number
    validate_port "$port"

    # Normalize protocol to uppercase
    protocol=$(echo "$protocol" | tr '[:lower:]' '[:upper:]')

    # Validate protocol
    if [[ "$protocol" != "TCP" && "$protocol" != "UDP" ]]; then
        error "Invalid protocol. Use 'TCP' or 'UDP'."
    fi

    ensure_path_exists "$DB_FILE" file

    # Check if the port exists in the database
    if ! grep -q "^${port}," "$DB_FILE" 2>/dev/null; then
        error "Port $port does not exist in the database."
    fi

    # Modify the entry
    sed -i "s/^${port},.*/${port},${protocol},${name},\"${description}\",$(date +'%Y-%m-%d %H:%M:%S')/" "$DB_FILE"
    log_action "INFO" "Modified port $port with protocol '$protocol', name '$name', description '$description'"
    log_history "MODIFY" "Port $port modified with protocol '$protocol', name '$name', description '$description'"
    highlight "Port $port has been successfully modified."

    backup_db
}

# Function to delete a port
function delete_port {
    local identifier="$1"

    ensure_path_exists "$DB_FILE" file

    if [[ "$identifier" =~ ^[0-9]+$ ]]; then
        # Delete by port
        if grep -q "^${identifier}," "$DB_FILE" 2>/dev/null; then
            sed -i "/^${identifier},/d" "$DB_FILE"
            log_action "INFO" "Deleted port $identifier"
            log_history "DELETE" "Port $identifier deleted"
            highlight "Port $identifier has been successfully deleted."
        else
            error "Port $identifier does not exist in the database."
        fi
    else
        # Delete by name
        if grep -q ",${identifier}," "$DB_FILE" 2>/dev/null; then
            sed -i "/,${identifier},/d" "$DB_FILE"
            log_action "INFO" "Deleted entry with name $identifier"
            log_history "DELETE" "Entry with name $identifier deleted"
            highlight "Entry with name $identifier has been successfully deleted."
        else
            error "No entry with name $identifier found in the database."
        fi
    fi

    backup_db
}

# Function to reset the database
function reset_db {
    echo "Are you sure you want to reset the database? This action cannot be undone. (y/n)"
    read -r confirmation
    if [[ "$confirmation" =~ ^[yY]$ ]]; then
        ensure_path_exists "$DB_FILE" file
        > "$DB_FILE"
        log_action "INFO" "Database reset"
        log_history "RESET" "Database reset"
        highlight "Database has been reset."
    else
        echo "Operation cancelled."
    fi
}

# Function to export the database to JSON (secured with jq)
function export_to_json {
    local output_file="$1"

    check_dependencies "jq"

    if [[ -z "$output_file" || "$output_file" == *[';|&']* ]]; then
        error "Invalid file path for export."
    fi

    ensure_path_exists "$DB_FILE" file
    ensure_path_exists "$output_file" file

    # Use jq to properly format JSON and escape special characters
    jq -n '[]' > "$output_file"

    if [ -s "$DB_FILE" ]; then
        while IFS=, read -r port protocol name description date_added; do
            # Remove quotes from description if present
            description=$(echo "$description" | sed 's/^"\(.*\)"$/\1/')

            # Use jq to create properly escaped JSON object
            jq -n \
                --arg port "$port" \
                --arg protocol "$protocol" \
                --arg name "$name" \
                --arg description "$description" \
                --arg date_added "$date_added" \
                '{port: $port, protocol: $protocol, name: $name, description: $description, date_added: $date_added}' \
                >> "${output_file}.tmp"
        done < "$DB_FILE"

        # Combine all JSON objects into an array
        jq -s '.' "${output_file}.tmp" > "$output_file"
        rm -f "${output_file}.tmp"
    fi

    log_action "INFO" "Exported database to JSON file $output_file"
    highlight "Database exported to $output_file"
}

# Function to import ports from CSV or JSON
function import_ports {
    local import_file="$1"

    if [ ! -f "$import_file" ]; then
        error "Import file $import_file does not exist."
    fi

    check_dependencies "jq"

    # Detect file type by extension
    if [[ "$import_file" == *.json ]]; then
        # Import from JSON
        local count=0
        while read -r port protocol name description; do
            add_port "$port" "$protocol" "$name" "$description" 2>/dev/null || {
                echo "Warning: Could not import port $port (may already exist or be invalid)" >&2
            }
            count=$((count + 1))
        done < <(jq -r '.[] | "\(.port) \(.protocol) \(.name) \(.description)"' "$import_file")

        highlight "Imported $count entries from $import_file"
    elif [[ "$import_file" == *.csv ]]; then
        # Import from CSV
        local count=0
        while IFS=, read -r port protocol name description _; do
            # Skip header line
            [[ "$port" == "port" ]] && continue

            add_port "$port" "$protocol" "$name" "$description" 2>/dev/null || {
                echo "Warning: Could not import port $port (may already exist or be invalid)" >&2
            }
            count=$((count + 1))
        done < "$import_file"

        highlight "Imported $count entries from $import_file"
    else
        error "Unsupported file format. Use .json or .csv files."
    fi
}

# Function to search ports
function search_ports {
    local keyword="$1"
    local count=0

    ensure_path_exists "$DB_FILE" file

    echo -e "+---------+------------+-------------------+-----------------------+---------------------+"
    echo -e "|  Port   |  Protocol  |       Name        |      Description      |     Date Added      |"
    echo -e "+---------+------------+-------------------+-----------------------+---------------------+"

    while IFS=, read -r port protocol name description date_added; do
        if echo "$name $description" | grep -iq "$keyword"; then
            description=$(echo "$description" | sed 's/^"\(.*\)"$/\1/')
            wrapped_description=$(echo "$description" | fold -s -w 22)
            first_line=true

            while IFS= read -r desc_line; do
                if [ -z "$desc_line" ]; then
                    desc_line=" "
                fi

                if [ "$first_line" = true ]; then
                    printf "| %-7s | %-10s | %-17s | %-21s | %-19s |\n" "$port" "$protocol" "$name" "$desc_line" "$date_added"
                    first_line=false
                else
                    printf "| %-7s | %-10s | %-17s | %-21s | %-19s |\n" " " " " " " "$desc_line" " "
                fi
            done <<< "$wrapped_description"
            count=$((count + 1))
        fi
    done < "$DB_FILE"

    echo -e "+---------+------------+-------------------+-----------------------+---------------------+"

    if [ "$count" -eq 0 ]; then
        echo "No matches found for '$keyword'."
    fi
}

# Function to sync Docker container ports (improved parsing)
function sync_docker_ports {
    local container_name="$1"  # "all" or a specific container name

    check_dependencies "docker"

    log_action "INFO" "Syncing Docker container ports with portmapper..."

    local synced_count=0

    # Get Docker container names and exposed ports
    docker ps --format "{{.Names}}|||{{.Ports}}" | while IFS='|||' read -r docker_container_name ports; do
        # Skip if a specific container is targeted and it doesn't match
        if [[ "$container_name" != "all" && "$docker_container_name" != "$container_name" ]]; then
            continue
        fi

        # Parse exposed ports - improved to handle multiple formats
        # Formats: 0.0.0.0:8080->80/tcp, :::8080->80/tcp, 8080->80/tcp
        echo "$ports" | grep -oE '([0-9.:]*)([0-9]+)->([0-9]+)/(tcp|udp)' | while read -r port_mapping; do
            # Extract external port (the one before ->)
            external_port=$(echo "$port_mapping" | sed -E 's/.*:([0-9]+)->.*/\1/')

            # If no colon found, it's a simple mapping
            if [[ ! "$port_mapping" =~ : ]]; then
                external_port=$(echo "$port_mapping" | cut -d'-' -f1)
            fi

            # Extract internal port and protocol
            internal_port=$(echo "$port_mapping" | sed -E 's/.*->([0-9]+)\/.*/\1/')
            protocol=$(echo "$port_mapping" | sed -E 's/.*\/(tcp|udp)/\1/' | tr '[:lower:]' '[:upper:]')

            # Check if the external port is already in the database
            if ! grep -q "^${external_port}," "$DB_FILE" 2>/dev/null; then
                # Add the port to the database
                add_port "$external_port" "$protocol" "$docker_container_name" "Docker container: $docker_container_name (internal port: $internal_port)" 2>/dev/null || {
                    log_action "WARNING" "Could not add Docker port $external_port (container: $docker_container_name)"
                }
                log_action "INFO" "Added Docker container port: $external_port (container: $docker_container_name, protocol: $protocol)"
                synced_count=$((synced_count + 1))
            else
                log_action "INFO" "Port $external_port already exists in the database (container: $docker_container_name)."
            fi
        done
    done

    if [[ "$container_name" == "all" ]]; then
        highlight "Docker container ports synced. Added $synced_count new ports."
    else
        highlight "Docker container ports for '$container_name' synced. Added $synced_count new ports."
    fi
}

# Function to backup the database
function backup_db {
    ensure_path_exists "$BACKUP_DIR" directory
    local timestamp
    timestamp=$(date +'%Y%m%d%H%M%S')

    if [ -f "$DB_FILE" ]; then
        cp "$DB_FILE" "$BACKUP_DIR/portmapper_${timestamp}.db" 2>/dev/null || {
            echo "Warning: Could not create backup" >&2
        }
        log_action "INFO" "Database backup created at $BACKUP_DIR/portmapper_${timestamp}.db"
    fi
}

# Function to restore the database
function restore_db {
    local backup_file="$1"
    if [ ! -f "$backup_file" ]; then
        error "Backup file $backup_file does not exist."
    fi
    cp "$backup_file" "$DB_FILE"
    log_action "INFO" "Database restored from $backup_file"
    highlight "Database has been restored from $backup_file."
}

# Function to start the REST API (improved and secured)
function start_api {
    local port="${1:-8080}"

    check_dependencies "jq"

    # Check if port is valid
    validate_port "$port"

    log_action "INFO" "Starting API on port $port"
    highlight "Starting REST API on port $port (press Ctrl+C to stop)"
    echo "Available endpoints:"
    echo "  GET  /ports       - List all ports"
    echo "  GET  /search?q=X  - Search ports"
    echo ""

    # Simple HTTP server using bash and netcat
    # Note: This is still basic. For production, use a proper web server.
    while true; do
        {
            read -r request_line

            # Parse HTTP method and path
            method=$(echo "$request_line" | cut -d' ' -f1)
            path=$(echo "$request_line" | cut -d' ' -f2)

            # Read headers (but don't use them for now)
            while read -r header; do
                [ "$header" = $'\r' ] && break
            done

            # Handle different endpoints
            if [[ "$method" == "GET" ]]; then
                if [[ "$path" == "/ports" ]]; then
                    # Return all ports as JSON
                    response=$(export_to_json /dev/stdout 2>/dev/null | jq -c '.')
                    echo -e "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\nAccess-Control-Allow-Origin: *\r\n\r\n$response"

                elif [[ "$path" =~ ^/search\?q=(.+)$ ]]; then
                    # Search functionality
                    query="${BASH_REMATCH[1]}"
                    query=$(echo "$query" | sed 's/%20/ /g') # URL decode spaces

                    echo -e "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n{\"query\": \"$query\", \"results\": []}"

                else
                    # 404 Not Found
                    echo -e "HTTP/1.1 404 Not Found\r\nContent-Type: application/json\r\n\r\n{\"error\": \"Not Found\"}"
                fi
            else
                # Method not allowed
                echo -e "HTTP/1.1 405 Method Not Allowed\r\nContent-Type: application/json\r\n\r\n{\"error\": \"Method Not Allowed\"}"
            fi
        } | nc -l -p "$port" -q 1
    done
}

# Function to display the version
function display_version {
    echo "portmapper version $VERSION"
}

# Function to display help
function display_help {
    echo "Usage:"
    echo "  portmapper               - List registered ports"
    echo "  portmapper -l, --list    - List registered ports"
    echo "  portmapper -n, --next    - Find the next available port"
    echo "  portmapper -a, --add <port> <protocol> <name> [<description>] - Add a new port (protocol: TCP or UDP, case-insensitive)"
    echo "  portmapper -m, --modify <port> <protocol> <name> <description> - Modify an existing port"
    echo "  portmapper -d, --delete <identifier> - Delete entry by port or name"
    echo "  portmapper -r, --remove <identifier> - Delete entry by port or name (same as -d)"
    echo "  portmapper --reset       - Reset the database"
    echo "  portmapper -h, --help    - Display this help message"
    echo "  portmapper -b, --backup  - Backup the database"
    echo "  portmapper -s, --search <keyword>  - Search ports by name or description"
    echo "  portmapper -e, --export <file>     - Export database to JSON file"
    echo "  portmapper --docker all            - Sync all Docker container ports"
    echo "  portmapper --docker <container>    - Sync ports for a specific Docker container"
    echo "  portmapper -i, --import <file>     - Import ports from a CSV or JSON file"
    echo "  portmapper --restore <backup-file> - Restore the database from a backup"
    echo "  portmapper --version     - Display the version"
    echo "  portmapper --api <port>  - Start the REST API"
}

# Main function
function main {
    # Acquire lock for write operations
    case "${1:-}" in
        -a|--add|-m|--modify|-d|--delete|-r|--remove|--reset|--restore|-i|--import|--docker)
            acquire_lock
            ;;
    esac

    # Trap to ensure lock is released on exit
    trap release_lock EXIT

    # Parse arguments
    case "${1:-}" in
        "")
            # No arguments - list ports
            list_ports
            ;;
        -l|--list)
            list_ports
            ;;
        -n|--next)
            next_port=$(find_next_free_port)
            echo "Next available port: $next_port"
            ;;
        -a|--add)
            if [ -z "${2:-}" ] || [ -z "${3:-}" ] || [ -z "${4:-}" ]; then
                error "Usage: portmapper --add <port> <protocol> <name> [<description>]"
            fi
            add_port "$2" "$3" "$4" "${5:-}"
            ;;
        -m|--modify)
            if [ -z "${2:-}" ] || [ -z "${3:-}" ] || [ -z "${4:-}" ] || [ -z "${5:-}" ]; then
                error "Usage: portmapper --modify <port> <protocol> <name> <description>"
            fi
            modify_port "$2" "$3" "$4" "$5"
            ;;
        -d|--delete|-r|--remove)
            if [ -z "${2:-}" ]; then
                error "Usage: portmapper --delete <identifier>"
            fi
            delete_port "$2"
            ;;
        --reset)
            reset_db
            ;;
        -s|--search)
            if [ -z "${2:-}" ]; then
                error "Usage: portmapper --search <keyword>"
            fi
            search_ports "$2"
            ;;
        -e|--export)
            if [ -z "${2:-}" ]; then
                error "Usage: portmapper --export <file>"
            fi
            export_to_json "$2"
            ;;
        -i|--import)
            if [ -z "${2:-}" ]; then
                error "Usage: portmapper --import <file>"
            fi
            import_ports "$2"
            ;;
        -b|--backup)
            backup_db
            highlight "Manual backup created successfully."
            ;;
        --restore)
            if [ -z "${2:-}" ]; then
                error "Usage: portmapper --restore <backup-file>"
            fi
            restore_db "$2"
            ;;
        --docker)
            if [ -z "${2:-}" ]; then
                error "Usage: portmapper --docker <container-name|all>"
            fi
            sync_docker_ports "$2"
            ;;
        --api)
            start_api "${2:-8080}"
            ;;
        --version)
            display_version
            ;;
        -h|--help)
            display_help
            ;;
        *)
            error "Unknown option: $1. Use --help for usage information."
            ;;
    esac
}

# Ensure database and log files exist
ensure_path_exists "$DB_FILE" file
ensure_path_exists "$LOG_FILE" file
ensure_path_exists "$HISTORY_FILE" file

# Run main function with all arguments
main "$@"
